(function(){"use strict";var e={9763:function(e,n,o){var i=o(9242),t=o(3396);function r(e,n,o,i,r,s){const a=(0,t.up)("Moebius");return(0,t.wg)(),(0,t.j4)(a)}function s(e,n,o,i,t,r){return null}var a=o(1114),l=o(4543),v=o(3440),u=o(2338),d=o(6664);const c="\n    varying vec2 vUv;\n    uniform vec2 uResolution;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n",m="\n    uniform sampler2D tDiffuse;\n    uniform vec2 uResolution;\n    uniform sampler2D uNormals;\n    uniform float timerRandoms[32];\n\n    varying vec2 vUv;\n\n    float rand(vec2 co){\n        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n    }\n\n    float randDispl(float xCoord, float yCoord, float resolutionX, float resolutionY, float factor, vec4 randVariables){\n        float randNum = rand(vec2(xCoord, yCoord));\n        float disp = ((1.0 + randNum) * (sin(yCoord*resolutionY / randVariables.x)) * factor + (1.0 + randNum) * (sin(yCoord*resolutionY / randVariables.y)) * factor  + (1.0 + randNum) * (sin(yCoord*resolutionY / randVariables.z)) * factor  + (1.0 + randNum) * (sin(yCoord*resolutionY / randVariables.w)) * factor) / 4.0;\n        return disp;\n    }\n\n    float valueAtPoint(sampler2D image, vec2 coord, vec2 texel, vec2 point) {\n        vec3 luma = vec3(0.299, 0.587, 0.114);\n        // here we have a rand so we have the pencil line effect\n        // 2.0*rand(coord)*\n        return dot(texture2D(image, coord + texel * point).xyz, luma);\n    }\n\n    float diffuseValue(float x, float y) {\n        return valueAtPoint(tDiffuse, vUv, vec2(1.0 / uResolution.x, 1.0 / uResolution.y), vec2(x, y)) * 0.6;\n    }\n    float normalValue(float x, float y) {\n        return valueAtPoint(uNormals, vUv, vec2(1.0 / uResolution.x, 1.0 / uResolution.y), vec2(x, y)) * 0.4;\n    }\n\n    float getValue(float x, float y) {\n        return diffuseValue(x, y) + normalValue(x, y);\n    }\n\n    float combinedSobelValue() {\n        // kernel definition (in glsl matrices are filled in column-major order)\n        const mat3 Gx = mat3(-1, -2, -1, 0, 0, 0, 1, 2, 1);// x direction kernel\n        const mat3 Gy = mat3(-1, 0, 1, -2, 0, 2, -1, 0, 1);// y direction kernel\n\n        // fetch the 3x3 neighbourhood of a fragment\n\n        // first column\n        float xDisp = randDispl(vUv.x, vUv.y, uResolution.x, uResolution.y, 1.5, vec4(22.0, 13.0, 37.0, 89.0));\n        float yDisp = randDispl(vUv.y, vUv.x, uResolution.y, uResolution.x, 1.5, vec4(22.0, 13.0, 37.0, 89.0));\n\n        float tx0y0 = getValue(-1.0+ xDisp, -1.0 + yDisp);\n        float tx0y1 = getValue(-1.0+ xDisp, 0.0 + yDisp);\n        float tx0y2 = getValue(-1.0+ xDisp, 1.0 + yDisp);\n\n        // second column\n        float tx1y0 = getValue(0.0+ xDisp, -1.0 + yDisp);\n        float tx1y1 = getValue(0.0+ xDisp, 0.0 + yDisp);\n        float tx1y2 = getValue(0.0+ xDisp, 1.0 + yDisp);\n\n        // third column\n        float tx2y0 = getValue(1.0+ xDisp, -1.0 + yDisp);\n        float tx2y1 = getValue(1.0+ xDisp, 0.0 + yDisp);\n        float tx2y2 = getValue(1.0+ xDisp, 1.0 + yDisp);\n\n        // gradient value in x direction\n        float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +\n        Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +\n        Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;\n\n        // gradient value in y direction\n        float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +\n        Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +\n        Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;\n\n        // magnitude of the total gradient\n        float G = (valueGx * valueGx) + (valueGy * valueGy);\n        return clamp(G, 0.0, 1.0);\n    }\n\n    float luma(vec4 color){\n        return 0.2126*color.x + 0.7152*color.y + 0.0722*color.z;\n    }\n    vec3 czm_saturation(vec3 rgb, float adjustment)\n    {\n        // Algorithm from Chapter 16 of OpenGL Shading Language\n        const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n        vec3 intensity = vec3(dot(rgb, W));\n        return mix(intensity, rgb, adjustment);\n    }\n\n\n\n    void main() {\n        float sobelValue = combinedSobelValue();\n        sobelValue = smoothstep(0.01, 0.03, sobelValue);\n\n        vec4 lineColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n        if (sobelValue > 0.1) {\n            gl_FragColor = lineColor;\n        } else {\n            vec4 normalColor = texture2D(uNormals, vUv);\n\n            // now we make the texture\n            if (normalColor.x > 2000.0 && normalColor.y > 2000.0 && normalColor.z > 2000.0){\n                gl_FragColor = vec4(240.0/255.0, 234.0/255.0, 214.0/255.0, 1.0);\n            }else if (normalColor.x > 100.0 && normalColor.y > 100.0 && normalColor.z > 100.0){\n                gl_FragColor = vec4(czm_saturation((texture2D(tDiffuse, vUv) * 0.5 + vec4(240.0/255.0, 234.0/255.0, 214.0/255.0, 1.0) * 0.5).xyz, 0.4), 1.0);\n            }else{\n                // we will also need to distort the texture a bit\n\n\n                float xDisps[5] = float[](randDispl(vUv.x, vUv.y, uResolution.x, uResolution.y, 1.5 / uResolution.x, vec4(22.0, 13.0, 37.0, 89.0)), randDispl(vUv.x, vUv.y, uResolution.x, uResolution.y, 1.5 / uResolution.x, vec4(timerRandoms[0], timerRandoms[1], timerRandoms[2], timerRandoms[3])), randDispl(vUv.x, vUv.y, uResolution.x, uResolution.y, 1.5 / uResolution.x, vec4(timerRandoms[4], timerRandoms[5], timerRandoms[6], timerRandoms[7])), randDispl(vUv.x, vUv.y, uResolution.x, uResolution.y, 1.5 / uResolution.x, vec4(timerRandoms[8], timerRandoms[9], timerRandoms[10], timerRandoms[11])), randDispl(vUv.x, vUv.y, uResolution.x, uResolution.y, 1.5 / uResolution.x, vec4(timerRandoms[12], timerRandoms[13], timerRandoms[14], timerRandoms[15])));\n\n                float yDisps[5] = float[](randDispl(vUv.y, vUv.x, uResolution.y, uResolution.x, 1.5 / uResolution.y, vec4(22.0, 13.0, 37.0, 89.0)), randDispl(vUv.y, vUv.x, uResolution.y, uResolution.x, 1.5 / uResolution.y, vec4(timerRandoms[16], timerRandoms[17], timerRandoms[18], timerRandoms[19])), randDispl(vUv.y, vUv.x, uResolution.y, uResolution.x, 1.5 / uResolution.y, vec4(timerRandoms[20], timerRandoms[21], timerRandoms[22], timerRandoms[23])), randDispl(vUv.y, vUv.x, uResolution.y, uResolution.x, 1.5 / uResolution.y, vec4(timerRandoms[24], timerRandoms[25], timerRandoms[26], timerRandoms[7])), randDispl(vUv.y, vUv.x, uResolution.y, uResolution.x, 1.5 / uResolution.y, vec4(timerRandoms[28], timerRandoms[29], timerRandoms[30], timerRandoms[31])));\n\n\n                vec2 vUvNew = vUv + vec2(xDisps[0], yDisps[0]);\n                gl_FragColor =  vec4(czm_saturation(texture2D(tDiffuse, vUvNew).xyz, 0.3), 1.0);\n\n                vec4 pixelColor = texture2D(tDiffuse, vUvNew);\n                float pixelLuma = luma(pixelColor);\n                if (pixelLuma <= 0.32){\n                    float stripe = mod((vUv.y * uResolution.y + vUv.x * uResolution.x) / 17.7, 4.0);\n                    if (stripe <= 1.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[1], yDisps[1]);\n                        if (mod(vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }else if (stripe <= 2.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[2], yDisps[2]);\n                        if (mod(vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                    else if (stripe <= 3.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[2], yDisps[2]);\n                        if (mod(vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                    else if (stripe <= 4.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[3], yDisps[3]);\n                        if (mod(vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                }\n                if (pixelLuma <= 0.48){\n                    float stripe = mod((vUv.y * uResolution.y + vUv.x * uResolution.x) / 17.7, 4.0);\n                    if (stripe <= 1.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[1], yDisps[1]);\n                        if (mod(vUvStripe.y * uResolution.y, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }else if (stripe <= 2.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[2], yDisps[2]);\n                        if (mod(vUvStripe.y * uResolution.y, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                    else if (stripe <= 3.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[2], yDisps[2]);\n                        if (mod(vUvStripe.y * uResolution.y, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                    else if (stripe <= 4.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[3], yDisps[3]);\n                        if (mod(vUvStripe.y * uResolution.y, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                }\n                if (pixelLuma <= 0.64){\n                    float stripe = mod((-vUv.y * uResolution.y + vUv.x * uResolution.x) / (17.7 + 5.0 * sin(-vUv.y * uResolution.y + vUv.x * uResolution.x)), 4.0);\n                    if (stripe <= 1.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[1], yDisps[1]);\n                        if (mod(-vUvStripe.y * uResolution.y + vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }else if (stripe <= 2.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[2], yDisps[2]);\n                        if (mod(-vUvStripe.y * uResolution.y + vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                    else if (stripe <= 3.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[2], yDisps[2]);\n                        if (mod(-vUvStripe.y * uResolution.y + vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                    else if (stripe <= 4.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[3], yDisps[3]);\n                        if (mod(-vUvStripe.y * uResolution.y + vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                }\n                if (pixelLuma <= 0.75){\n                    float stripe = mod((vUv.y * uResolution.y + vUv.x * uResolution.x) / (17.7 + 5.0 * sin(vUv.y * uResolution.y + vUv.x * uResolution.x)), 4.0);\n                    if (stripe <= 1.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[1], yDisps[1]);\n                        if (mod(vUvStripe.y * uResolution.y + vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }else if (stripe <= 2.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[2], yDisps[2]);\n                        if (mod(vUvStripe.y * uResolution.y + vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                    else if (stripe <= 3.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[2], yDisps[2]);\n                        if (mod(vUvStripe.y * uResolution.y + vUvStripe.x * uResolution.x, 17.7) <=1.5){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                    else if (stripe <= 4.0){\n                        vec2 vUvStripe = vUv + vec2(xDisps[3], yDisps[3]);\n                        if (mod(vUvStripe.y * uResolution.y + vUvStripe.x * uResolution.x, 17.7) <=1.){\n                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                        }\n                    }\n                }\n                if (pixelLuma > 0.75){\n                    gl_FragColor = vec4(czm_saturation((texture2D(tDiffuse, vUv) * 0.7 + vec4(240.0/255.0, 234.0/255.0, 214.0/255.0, 1.0) * 0.3).xyz, 0.4), 1.0);\n                }\n            }\n        }\n    }\n";class p extends a.jyz{constructor(){super({uniforms:{tDiffuse:{value:null},uNormals:{value:null},timerRandoms:{value:[]},uResolution:{value:new a.FM8(1,1)}},fragmentShader:m,vertexShader:c})}}class f extends d.w{constructor(e,n,o,i){super(),this.scene=o,this.camera=i,this.material=new p,this.randomNumbers=new Array(32);for(var t=0;t<32;t++)this.randomNumbers[t]=90*Math.random()+7;this.material.uniforms.timerRandoms.value=this.randomNumbers,this.lastTime=Date.now(),this.fsQuad=new d.T(this.material),this.material.uniforms.uResolution.value=new a.FM8(e,n);const r=new a.dd2(e,n);r.texture.format=a.wk1,r.texture.type=a.cLu,r.texture.minFilter=a.TyD,r.texture.magFilter=a.TyD,r.texture.generateMipmaps=!1,r.stencilBuffer=!1,this.normalBuffer=r,this.normalMaterial=new a.jyz({uniforms:{lightPos:{value:new a.Pa4(0,4,0)},cameraPos:{value:new a.Pa4(0,0,0)}},vertexShader:"\n            varying vec3 vNormal;\n            varying vec3 vWorldPosition;\n        \n            void main() {\n                vNormal = normalize(mat3(modelMatrix) * normal);\n                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n                gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));\n            }\n            \n            ",fragmentShader:"\n            uniform vec3 cameraPos;\n            uniform vec3 lightPos; // in world space\n        \n            varying vec3 vNormal;\n            varying vec3 vWorldPosition;\n        \n            void main() {\n                // Calculate view direction in world space\n                vec3 viewDir = normalize(cameraPos - vWorldPosition);\n        \n                // Specular term\n                vec3 lightDir = normalize(lightPos - vWorldPosition);\n                vec3 reflectDir = reflect(-lightDir, vNormal);\n                float spec = pow(max(dot(viewDir, reflectDir), 0.0), length(lightPos - vWorldPosition) * 4.0);\n                // gl_FragColor = vec4(spec, spec, spec, 1.0);\n\n                // diffuse term\n                float diff = max(dot(vNormal, lightDir), 0.0);\n                if (spec > 0.59){\n                    gl_FragColor = vec4(100000.0, 100000.0, 100000.0, 1.0);\n                }else if (diff > 0.95){\n                    gl_FragColor = vec4(2000.0, 2000.0, 2000.0, 1.0);\n                }else{\n                    gl_FragColor = vec4(vNormal, 1.0);\n                }\n                // gl_FragColor = vec4(viewDir, 1.0);\n            }\n            "})}dispose(){this.material.dispose(),this.fsQuad.dispose()}render(e,n,o){e.setRenderTarget(this.normalBuffer);const i=this.scene.overrideMaterial;this.normalMaterial.uniforms.cameraPos.value=this.camera.position,this.scene.overrideMaterial=this.normalMaterial,e.render(this.scene,this.camera),this.scene.overrideMaterial=i,this.material.uniforms.uNormals.value=this.normalBuffer.texture,this.material.uniforms.tDiffuse.value=o.texture;var t=Date.now();if(t-this.lastTime>1e3){for(var r=0;r<32;r++)this.randomNumbers[r]=40*Math.random()+7;this.material.uniforms.timerRandoms.value=this.randomNumbers,this.lastTime=Date.now()}this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(n),this.clear&&e.clear(),this.fsQuad.render(e))}changeLight(e){this.normalMaterial.uniforms.lightPos.value=e}resize(e,n){this.material.uniforms.uResolution.value=new a.FM8(e,n)}}var x=o(5861),y=o(9066),h=o(8281);const g=new a.xsS,R=new a.cPb(60,window.innerWidth/window.innerHeight,.1,1e3);R.position.z=8,R.position.y=0;const w=new a.FE5(1,.4,500,32),D=new a.Wid({color:65280,emissive:65280,emissiveIntensity:.1}),U=new a.Kj0(w,D);U.rotation.y=Math.PI,U.castShadow=!0,U.position.set(-4,0,0),g.add(U);const S=new a.Kgo(2,0),C=new a.Wid({color:16427535,emissive:16427535,emissiveIntensity:.1}),b=new a.Kj0(S,C);b.rotation.y=Math.PI,b.castShadow=!0,b.position.set(4,0,0),g.add(b);const _=new a.Kj0(new a._12(18,18),new a.Wid({color:16755661,emissive:16755661,emissiveIntensity:.1}));_.position.z=-9,_.receiveShadow=!0,_.material.side=a.ehD,g.add(_);const M=new a.Kj0(new a._12(18,18),new a.Wid({color:11259391,emissive:11259391,emissiveIntensity:.1}));M.rotation.y=Math.PI/2,M.position.x=-9,M.receiveShadow=!0,M.material.side=a.ehD,g.add(M);const z=new a.Kj0(new a._12(18,18),new a.Wid({color:11272141,emissive:11272141,emissiveIntensity:.1}));z.rotation.y=-Math.PI/2,z.position.x=9,z.receiveShadow=!0,z.material.side=a.ehD,g.add(z);const P=new a.Kj0(new a._12(18,18),new a.Wid({color:12385021,emissive:12385021,emissiveIntensity:.6}));P.rotation.x=Math.PI/2,P.position.y=9,P.receiveShadow=!0,P.material.side=a.ehD,g.add(P);const F=new a.Kj0(new a._12(18,18),new a.Wid({color:16432351,emissive:16432351,emissiveIntensity:.6}));F.rotation.x=-Math.PI/2,F.position.y=-9,F.receiveShadow=!0,F.material.side=a.ehD,g.add(F);const j=new h.j;j.load("Fennec_Fox.stl",(function(e){const n=new a.Kj0(e,new a.Wid({color:64202,emissive:64202,emissiveIntensity:0}));n.scale.set(.07,.07,.07),n.rotation.x=-Math.PI/2,n.geometry.center(),n.castShadow=!0,g.add(n)}),(e=>{console.log(e.loaded/e.total*100+"% loaded")}),(e=>{console.log(e)}));const G=new a.cek(15788758,800);G.castShadow=!0,G.position.set(0,4,0),G.shadow.mapSize.width=2048,G.shadow.mapSize.height=2048,g.add(G);const V=new a.CP7({antialias:!0});V.setSize(window.innerWidth,window.innerHeight),V.setClearColor("#eee"),V.physicallyCorrectLights=!0,V.outputEncoding=a.knz,V.toneMapping=a.YGz,V.toneMappingExposure=1.75,V.shadowMap.enabled=!0,V.shadowMap.type=a.ntZ,V.setClearColor(10597360,1),document.body.appendChild(V.domElement);const W=new v.x(V),N=new u.C(g,R),I=new f(V.domElement.clientWidth,V.domElement.clientHeight,g,R),L=new y.T(x.Y);W.addPass(N),W.addPass(L),W.addPass(I);const E=new l.z(R,V.domElement);function k(){requestAnimationFrame(k),U.rotation.y+=.013+.002*Math.random(),U.rotation.x+=.007+.008*Math.random(),U.rotation.z+=.009+.006*Math.random(),b.rotation.x+=(.006+.004*Math.random())/2,b.rotation.z-=(.003+.007*Math.random())/2,b.rotation.y-=(.008+.002*Math.random())/2,E.update(),W.render()}E.addEventListener("change",(e=>{var n=new a.Pa4(E.object.position.x+0,1.5*E.object.position.y+4,E.object.position.z+8);G.position.set(n.x,n.y,n.z),I.changeLight(n)})),E.autoRotate=!0,k();var T={name:"Moebius",data(){return{}},computed:{},methods:{onWindowResize(){R.aspect=window.innerWidth/window.innerHeight,R.updateProjectionMatrix(),V.setSize(window.innerWidth,window.innerHeight),I.resize(V.domElement.clientWidth,V.domElement.clientHeight)}},async mounted(){window.addEventListener("resize",this.onWindowResize),I.resize(V.domElement.clientWidth,V.domElement.clientHeight);var e=new a.Pa4(E.object.position.x+0,1.5*E.object.position.y+4,E.object.position.z+8);G.position.set(e.x,e.y,e.z),I.changeLight(e),window.addEventListener("keypress",(e=>{" "==e.key&&(E.autoRotate=!E.autoRotate)}))}},O=o(89);const K=(0,O.Z)(T,[["render",s],["__scopeId","data-v-39ac2a22"]]);var A=K,H={name:"App",components:{Moebius:A}};const Y=(0,O.Z)(H,[["render",r]]);var B=Y;(0,i.ri)(B).mount("#app")}},n={};function o(i){var t=n[i];if(void 0!==t)return t.exports;var r=n[i]={exports:{}};return e[i].call(r.exports,r,r.exports,o),r.exports}o.m=e,function(){var e=[];o.O=function(n,i,t,r){if(!i){var s=1/0;for(u=0;u<e.length;u++){i=e[u][0],t=e[u][1],r=e[u][2];for(var a=!0,l=0;l<i.length;l++)(!1&r||s>=r)&&Object.keys(o.O).every((function(e){return o.O[e](i[l])}))?i.splice(l--,1):(a=!1,r<s&&(s=r));if(a){e.splice(u--,1);var v=t();void 0!==v&&(n=v)}}return n}r=r||0;for(var u=e.length;u>0&&e[u-1][2]>r;u--)e[u]=e[u-1];e[u]=[i,t,r]}}(),function(){o.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(n,{a:n}),n}}(),function(){o.d=function(e,n){for(var i in n)o.o(n,i)&&!o.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})}}(),function(){o.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}()}(),function(){o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)}}(),function(){var e={143:0};o.O.j=function(n){return 0===e[n]};var n=function(n,i){var t,r,s=i[0],a=i[1],l=i[2],v=0;if(s.some((function(n){return 0!==e[n]}))){for(t in a)o.o(a,t)&&(o.m[t]=a[t]);if(l)var u=l(o)}for(n&&n(i);v<s.length;v++)r=s[v],o.o(e,r)&&e[r]&&e[r][0](),e[r]=0;return o.O(u)},i=self["webpackChunkmoebius_render"]=self["webpackChunkmoebius_render"]||[];i.forEach(n.bind(null,0)),i.push=n.bind(null,i.push.bind(i))}();var i=o.O(void 0,[998],(function(){return o(9763)}));i=o.O(i)})();
//# sourceMappingURL=app.1895eda8.js.map